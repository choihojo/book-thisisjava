# 1.4 바이트코드 파일과 자바 가상 머신

## 1.4.1 바이트코드 파일

`.java` 소스 파일을 작성한 후에는 컴파일을 해야 한다. `javac` 명령어는 소스 파일을 컴파일하는데, 컴파일 결과는 `.class`인 바이트코드 파일로 생성된다. 바이트코드는 JVM에 의해 실행되는 바이너리 코드다. 생성되는 바이트코드 파일은 OS에 구애받지 않는다. 바이트코드 파일은 자바의 목적 파일이라고 간주할 수 있다.

```
C:\Users\developer\Desktop\root\book\book-thisisjava\src\ch01\sec05>javac -d bin Hello.java
```

## 1.4.2. 자바 가상 머신

`.class` 바이트코드 파일을 OS가 이해하는 기계어로 번역하고 실행시키는 명령어는 `java`이다. `java` 명령어는 JDK와 함께 설치된 JVM을 구동시켜 바이트코드 파일을 완전한 기계어로 번역하고 실행시킨다.

바이트코드 파일은 OS에 구애받지 않고 모두 동일한 내용으로 생성되지만, JVM은 OS에서 이해하는 기계어로 번역해야 하므로 OS별로 다르게 설치된다. 그래서 OS별로 설치하는 JDK가 다르다. 자바는 플랫폼에 독립적이지만 JVM은 플랫폼에 종속적이다.

JVM은 일반적으로 소프트웨어로 작성되지만, 자바 터미널과 같이 하드웨어로 만들어지기도 한다.

```
C:\Users\developer\Desktop\root\book\book-thisisjava\src\ch01\sec05>java -cp bin ch01.sec05.Hello
Hello, Java
```

패키지 구분자는 `.`을 사용해야 하고, 클래스명은 `.class`를 제외한 Hello만 입력해야 한다.

## 1.4.3. 플랫폼 독립성

C나 C++ 같은 경우 컴파일되면 CPU와 OS에 종속적인 기계어로 변환된다. 예를 들어 Intel CPU와 Linux OS에서 컴파일된 기계어 코드는 Intel CPU와 Windows OS가 탑재된 컴퓨터에서는 실행되지 않는다. Intel CPU가 아닌 AMD CPU를 사용하더라도 같은 명령에 대해서 변환되는 기계어가 다를 수 있다. 그래서 C, C++ 프로그램의 경우 각 플랫폼에 맞는 기계어 프로그램을 생성해야 한다. 이를 `플랫폼 종속성`이라고 한다.

이에 반해 자바는 `플랫폼 독립성`을 가지도록 설계되었다. 1991년에 SUN Microsystems에서 제임스 고슬링을 필두로 가전제품의 소프트웨어 개발에 적합한 프로그래밍 언어를 개발하기 시작했다. 기존 언어로 작성된 프로그램은 플랫봄 종속적이어서 플랫폼에 따라 소스를 다시 컴파일하거나 아예 프로그램을 새로 작성해야 하는 단점이 있었다. 특히 가전제품은 CPU의 종류를 포함한 하드웨어 플랫폼이 매우 다양했기 때문에 플랫폼에 독립적인 언어가 요구되었다. 그래서 Oak라는 언어가 개발되었다. 그렇지만 Oak는 가전제품 특성상 매우 적은 메모리를 사용해야한다는 조건을 충족하지 못해서 주목받지 못했다.

Oak는 인터넷과 웹이 발전하면서 널리 알려지게 되었다. Oak가 웹용 개발 언어인 HTML의 정적이라는 단점을 보완할 수 있을 것이라 기대하여 Oak를 웹과 융합시킨 결과로 자바가 개발되었다. 자바는 CPU, OS에 구애받지 않고 JVM만 있으면 어떤 컴퓨터에서든 동일하게 실행된다.

참고로 C, C++은 컴파일한 목적 파일을 링크시켜 하나의 실행 파일을 만들며, 동일한 플랫폼이라는 가정 하에 실행 파일 하나만 있으면 실행이 가능하다. 이 실행 파일은 CPU가 바로 실행한다.

반대로 자바의 경우 링크 과정이 없으며 JVM이 컴파일된 바이트코드 파일을 실행한다. 자바는 컴파일된 바이트코드 파일들이나 이들을 하나로 압축한 jar 파일 형태로 배포한다.
